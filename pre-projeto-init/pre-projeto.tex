%% abtex2-modelo-relatorio-tecnico.tex, v<VERSION> laurocesar
%% Copyright 2012-2015 by abnTeX2 group at http://www.abntex.net.br/ 
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%%
%% This work has the LPPL maintenance status `maintained'.
%% 
%% The Current Maintainer of this work is the abnTeX2 team, led
%% by Lauro César Araujo. Further information are available on 
%% http://www.abntex.net.br/
%%
%% This work consists of the files abntex2-modelo-relatorio-tecnico.tex,
%% abntex2-modelo-include-comandos and abntex2-modelo-references.bib
%%

% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% abnTeX2: Modelo de Relatório Técnico/Acadêmico em conformidade com 
% ABNT NBR 10719:2011 Informação e documentação - Relatório técnico e/ou
% científico - Apresentação
% Adaptado por Daniel Saad Nogueira Nunes para uso no IFB Taguatinga.
% ------------------------------------------------------------------------ 
% ------------------------------------------------------------------------


% Como opção escolha 'bacharelado' ou 'licenciatura'
\documentclass[bacharelado]{pre-projeto-computacao}
% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\titulo{Comparação de Algoritmos de Menor Caminho em Grafos: Um estudo sobre o comportamento prático de algoritmos}
\autor{Giovanni Lucas Oliveira da Silva}
% para feminino use \orientadora{Nome da orientadora}
%\orientadora{Maria Bonita}
\orientador{Daniel Saad Nogueira Nunes}

% para masculino use \coorientador{Nome do coorientador}
%\coorientador{Padre Cícero}
%\coorientadora{Maria Bonita}

% Linha de pesquisa conforme tabela de áreas do CNPq
\areadepesquisa{Análise de Algoritmos e Complexidade de Computação}
\local{Brasília, DF}
\data{2025 }

\begin{document}

\selectlanguage{brazil}
\frenchspacing 
\imprimircapa
\imprimirfolhaderosto

\section*{Introdução}

  Dados, no ramo da ciência da computação, têm uma importância fundamental para o computador cumprir suas finalidades \cite{cruz2014-aedi}. Podemos usar os dados para representar coisas simples como números ou textos, ou coisas mais complexas como imagens e vídeos, ou até representações de pessoas, lugares e objetos reais. Toda aquisição de dados normalmente é feita com o propósito de que sejam utilizados para alguma finalidade, seja para o armazenamento de informações, ou para a realização de algum processamento e tomada de decisões.

  Esses dados precisam ser armazenados de alguma forma eficiente, para que possam ser analisados e utilizados posteriormente, e é aí que se fazem importantes as estruturas de dados. Uma estrutura de dados é um modo de armazenar e organizar dados com o objetivo de facilitar acesso e modificações \cite{cormen2012-algoritmos}, existem várias estruturas de dados, cada uma com suas características, vantagens e desvantagens. A escolha da estrutura de dados correta para um determinado problema é crucial para o desempenho e eficiência do tratamento desses dados e, consequentemente, para a realização de tarefas e resolução de problemas.

  Com o avanço da internet, a quantidade de dados gerados cresceu de forma significativa. Dados esses correspondem muita das vezes a representações de relações entre diferentes objetos, como pessoas, locais e outros elementos. De acordo com o relatório \textit{Data Age 2025}, publicado pela IDC, em 2015 cada pessoa gerava, em média, cerca de 1,3 GB de dados por dia. A previsão era que, em 2025, esse número chegasse a 5,3 GB diários, incluindo interações em redes sociais, pesquisas na web, uso de aplicativos, comunicações e outras atividades digitais \cite{linkages2023}. Tais relações de dados podem ser modeladas por meio de uma estrutura fundamental chamada grafo. Trata-se de uma das estruturas de dados mais utilizadas justamente por permitir modelar objetos --- chamados de vértices --- e as conexões entre eles, denominadas arestas. Cada aresta simboliza um vínculo entre dois vértices, que pode representar, por exemplo, a amizade entre duas pessoas ou a rota que liga duas cidades. \cite{groner2019-estruturas}

  Tomando como por exemplo as aplicações de geolocalização, ter um grafo representando as rotas entre cidades torna esses dados mais fáceis de serem analisados e processados, se colocarmos valores nas arestas representando a distância entre as cidades, quando um usuário quiser ir de uma cidade A para uma outra cidade B, podemos com esse grafo analisar as diversas rotas possíveis entre essas duas cidades caso haja mais de uma rota, ou se até mesmo não houver uma rota direta entre essas duas cidades, e assim determinar diversas possibilidades de rotas que o usuário pode fazer para ir de A para B. Mas dentre todas essas rotas possíveis, surge problemas: Como B é alcançável a partir de A? Qual a rota mais curta entre A e B? Quais são as rotas que passam por uma outra cidade C? Esses são problemas entre muitos outros que podem surgir quando trabalhamos com essas questões. Nesse pré-projeto vamos focar em um dos problemas mais comuns e importantes que é o problema em determinar qual a rota mais curta entre dois vértices. Esse problema é mais referido como o problema do menor caminho.\cite{lintzmayer2023-aaed}\cite{groner2019-estruturas}

  Esse problema é encontrado em diversas aplicações do mundo real, como nesse caso de geolocalização e navegação, em muitas outras aplicações como redes sociais, jogos, entre outros. E para solucionar esse problema, as pessoas desenvolveram soluções que chamamos de algoritmos, uma sequência de passos definidos que levam a uma solução.\cite{cormen2012-algoritmos} Para o problema do menor caminho, existem diversos algoritmos desenvolvidos, cada um com suas características, vantagens e desvantagens.

  Alguns dos algoritmos mais conhecidos para resolver o problema do menor caminho são os algoritmos de Dijkstra \cite{dijkstra1959note}, Bellman-Ford \cite{bellman1958routing} \cite{ford1956networkflow} e o Floyd-Warshall \cite{floyd1962shortest} \cite{warshall1962boolean}, cada um desses algoritmos tem uma analise assintótica diferente, essas analises nos permitem prever o desempenho de um algoritmo sem a necessidade de implementá-lo e testá-lo, o que é muito útil quando estamos lidando com grandes quantidades de dados. \cite{lintzmayer2023-aaed} Porém, essas análises são apenas previsões teóricas, e o desempenho real de um algoritmo pode variar dependendo de muitos fatores. Por isso, é importante não apenas analisar os algoritmos teoricamente, mas também testá-los na prática.

  Recentemente um novo algoritmo de menor caminho foi proposto em uma pesquisa intitulada ``Breaking the Sorting Barrier for Directed Single-Source Shortest Paths"  \cite{duan2025breaking} este algoritmo tem um tempo de execução determinístico assintoticamente menor que o Dijkstra, o que é uma grande proposta, visto que ele é um dos algoritmos mais eficientes para resolver problemas de menor caminho em grafos. \cite{lintzmayer2023-aaed} A analise assintotica descreve como o tempo de execucao de um algoritmo escala conforme o tamanho da entrada cresce. Ela nao mede o tempo em segundos, mas sim a ordem de crescimento, ignorando constantes e termos de ordem inferior. Embora seja essencial para comparar algoritmos teoricamente, em situacoes praticas pode levar a conclusoes enganosas. Por exemplo, algoritmos de complexidade $\mathcal{O}(n \log n)$, como o \textit{MERGE SORT}, podem ser mais lentos em entradas pequenas do que algoritmos de $\mathcal{O}(n^2)$, como o \textit{INSERTION SORT}, devido ao peso das constantes escondidas. De forma semelhante, o algoritmo de Dijkstra com fila de prioridade implementada por \textit{Fibonacci Heap} possui melhor complexidade assintotica, mas na pratica costuma ser superado pela versao com \textit{Binary Heap}, que e mais simples e eficiente em cenarios reais. Teoricamente esse algoritmo quebrou uma barreira que a muito tempo era considerada a mais eficiente nesse problema, mas como falado anteriormente, o desempenho real desse algoritmo será diferente do desempenho teórico, e com isso podemos indagar: Será que esse algoritmo vai trazer ganhos práticos em relação ás praticas atuais? Será que é de fato mais rápido que o Dijkstra em grafos reais?

\section*{Proposta}

\subsection*{Objetivo Geral}

  O trabalho se propõe a investigar a discrepância entre o ganho de eficiência teórico e prático do novo algoritmo para o Problema do Menor Caminho de Fonte Única (SSSP), em comparação com o algoritmo de Dijkstra. Para isso, o cerne deste projeto foca na realização de estudos de benchmark. Quantificando e analisando o tempo de execução de cada algoritmo nessas diferentes situações em grafos. Dessa forma, será possível determinar se o avanço assintótico do novo algoritmo se traduz em ganhos de desempenho prático significativos, e em quais condições específica ele consegue, de fato, superar a eficiência consolidada do algoritmo de Dijkstra.

\subsection*{Objetivos Específicos}

  \begin{itemize}
    \item Analisar a Complexidade: Realizar a comparação assintótica formal entre o novo algoritmo e os algoritmos clássicos de SSSP, estabelecendo o potencial ganho de eficiência em termos teóricos.
    \item Testar a Performance Prática: Determinar o comportamento prático do novo algoritmo através de testes em uma ampla variedade de benchmarks de grafos, medindo e quantificando seu tempo de execução e consumo de recursos.
    \item Quantificar o Ganho de Desempenho: Mensurar o grau de avanço prático do algoritmo de DUAN et al. em relação ao algoritmo de Dijkstra.
  \end{itemize}

\section*{Justificativa}

  O problema do menor caminho não é um problema puramente acadêmico, ele é um problema que é presente em vários ambitos descritos anteriormente, e por isso, ter algoritmos mais eficientes para resolver esse problema é de grande importância. E para que possamos ter certa clareza sobre a eficiência de algoritmos que se propoem a serem mais rápidos que os já utilizados atualmente, é necessário que seja verificada a sua validade prática, ou seja, criando evidências empíricas que comprovem a sua superioridade. Esse estudo baseado em benchmarks permite o fornecimento de dados concretos sobre o desempenho real, aplicando os fatores ignorados pela notação assintótica em seu resultado.

  Esses resultados terão impacto prático direto pois, se o novo algoritmo se mostrar de fato mais eficiente, essa informação influenciará decisões de engenharia e desenvolvimento de software, levando a escolhas mais informadas sobre quais algoritmos utilizar em aplicações que envolvem o problema do menor caminho. Além disso, esse estudo contribuirá para a comunidade acadêmica e profissional ao fornecer uma análise crítica e detalhada sobre a aplicabilidade prática de avanços teóricos em algoritmos, incentivando futuras pesquisas e inovações na área.

\section*{Proposta Metodológica Preliminar}
  
  A metodologia de pesquisa será de natureza experimental e quantitativa, focada na implementação detalhada de ambos os algoritmos: o novo algoritmo assintoticamente mais rápido e o algoritmo clássico de Dijkstra. Ambos serão implementados fielmente na linguagem \textbf{C++} para garantir máxima eficiência e controle sobre o overhead. A avaliação prática será direcionada por meio de um ambiente de testes realista e controlado, utilizando conjuntos de dados e \textit{frameworks} de \textit{benchmark} de grafos. Ferramentas como o \textbf{BGGS (\textit{Big Graph Generator Suite})} serão empregadas para a geração de grafos sintéticos, simulando cenários que variam em escala, densidade e estrutura, refletindo a complexidade de aplicações do mundo real. O tempo de execução será mensurado com alta precisão e repetido múltiplas vezes. Por fim, os resultados serão analisados para comparar o desempenho dos algoritmos em diferentes cenários, validando a aplicabilidade prática do avanço teórico do algoritmo. \cite{duan2025breaking}

\bibliography{bibliografia}

\end{document}
